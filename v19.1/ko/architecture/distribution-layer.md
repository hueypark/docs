---
title: 분산 계층
summary: 카크로치디비 아키텍처의 분산 계층은 클러스터 데이터의 통합된 뷰를 제공합니다.
toc: true
---

카크로치디비 아키텍처의 분산 계층은 클러스터 데이터의 통합된 뷰를 제공합니다.

{{site.data.alerts.callout_info}}
[아키텍처 개요](overview.html)를 먼저 읽어보는 것을 권장합니다.
{{site.data.alerts.end}}

## 개요

모든 노드에서 모든 데이터에 접근할 수 있게 하기 위해, 카크로치디비는 정렬된 모놀리식 맵에 키-밸류 값을 저장합니다. 이 키 공간은 클러스터 내 모든 데이터의 위치를 나타내며, 우리가 "레인지"라고 말하는, 키 공간의 연속된 청크로 나뉘어, 모든 키가 항상 단일 레인지에서 검색가능합니다.

카크로치디비는 정렬된 맵을 구현하여 다음을 가능하게 합니다:

  - **간단한 조회**: 데이터의 특정 부분을 어떤 노드가 담당하는지 알기 때문에, 쿼리는 원하는 데이터를 찾을 수 있는 위치를 빨리 찾을 수 있습니다.
  - **효율적인 검색**: 데이터가 정렬되어 있기 때문에, 검색을 하는 동안 특정 레인지의 데이터를 쉽게 찾을 수 있습니다.

### 모놀리식 정렬 맵 구조

모놀리식 정렬 맵은 두 가지 기본요소로 구성됩니다:

- 시스템 데이터, 클러스터의 데이터 위치(클러스터 전반에 걸쳐 퍼져있는)를 표현하는 **메타 레인지**가 포함됩니다.
- 유저 데이터, 클러스터의 **테이블 데이터**를 저장합니다.

#### 메타 레인지

클러스터의 모든 레인지 위치는 키 공간 시작부터 2단계 인덱스로 저장되며, 첫 번째 레벨(`meta1`) 은 두 번째 레벨의 주소이고, 두 번째(`meta2`)는 클러스터의 데이터 주소입니다. 중요한 것은, 모든 노드가 `meta1` 레인지(레인지 디스크립터라고 불리며, 아래에 세부설명은 아래에 있음)를 찾을 위치에 대한 정보를 가지고 있고, 레인지는 절대 분할되지 않는다는 점입니다.

이 메타 레인지 구조로 최대 4EiB의 사용자 데이터를 처리가능합니다: 우리는 2^(18 + 18) = 2^36 개의 레인지를 수용가능합니다; 각 레인지는 2^26 B를 가리키므로, 총 2^(36+26) B = 2^62 B = 4EiB의 주소를 지정합니다. 또, 더 큰 레인지가 필요하다면 추후에 이 용량을 더 확장할 수 있습니다.

메타 레인지는 일반 레인지처럼 처리되며 클러스터 KV 데이터의 다른 요소와 마찬가지로 접근되고 복제됩니다.

각 노드는 이전에 접근한 `meta2` 레인지 값을 캐시하여 이후 해당 데이터에 대한 접근을 최적화합니다. 노드가 특정 키에 대한 `meta2` 캐시가 유효하지 않은 것을 발견할 때마다, `meta2` 레인지에 대한 정규 읽기를 수행하여 갱신합니다.

#### 테이블 데이터

노트의 메타 레인지 다음은 클러스터에 저장된 KV 데이터입니다.

각 테이블과 보조 인덱스는 최초에 하나의 레인지로 매핑됩니다. 여기서 키-밸류 쌍은 테이블의 단일 행(테이블이 기본키로 정렬되기 때문에 기본 인덱스라고도 함) 또는 보조 인덱스를 나타냅니다. 레인지 크기가 64MiB가 되면, 두 개의 레인지로 나뉩니다. 이 프로세스는 테이블에서 계속 진행되며 인덱스는 계속 증가합니다. 테이블이 여러 레인지로 분할되면, 테이블과 보조 인덱스가 분산된 레인지에 저장될 가능성이 큽니다. 그러나, 레인지는 여전히 테이블과 보조 인덱스를 포함할 수 있습니다.

기본값인 64MiB 레인지 크기는 노드 사이에서 빠르게 이동하기에 충분히 작은 크기이고, 함께 접근될 가능성이 높은 데이터가 의미있을 만큼 인접해서 저장할만큼 충분히 큽니다. 이 레인지들은 생존성을 보장하기 위해 클러스터에 퍼집니다.

이 테이블 레인지는 복제되며(복제 계층에서), 각 레플리카의 주소는 `meta2` 레인지에 저장합니다.

### 모놀리식 정렬 맵 구조 사용하기

노드는 요청을 받으면, 메타 레인지를 확인하여 요청의 키를 `meta2` 레인지의 키와 비교하여 요청을 전달할 노드를 찾습니다.

이 메타 레인지는 많이 캐시되기 때문에, 보통 RPC를 보낼 필요 없이 `meta2` 레인지를 포함하는 노드로 이동합니다.

노드는 `meta2` 레인지에서 식별한 리스홀더에게 KV 작업을 보냅니다. 그러나, 데이터가 이동되었을 수 있는데, 이 경우 정보가 없는 노드는 요청 노드에게 데이터가 없다고 응답합니다. 그러면 `meta2` 레인지로 돌아가 최신 정보를 얻어 다시 시도합니다.

### 다른 계층과의 상호작용

카크로치디비에서 분산 계층의 다른 계층과의 상호작용은 다음과 같습니다:

- 동일 노드의 트랜잭션 계층으로부터 요청을 받습니다.
- 요청을 받아야 하는 노드를 식별한 다음, 해당 노드의 복제 계층으로 요청을 전송합니다.

## 기술 세부사항과 구성요소

### gRPC

gRPC는 노드가 서로 통신하기 위해 사용하는 소프트웨어입니다. 배포 계층은 다른 노드와 통신하기 위한 첫 계층이므로 카크로치디비는 gRPC를 여기에 구현합니다.

gRPC는 입출력을 프로토콜 버퍼(protobufs)를 사용합니다. gRPC를 활용하기 위해 카크로치디비는 `api.proto`에 정의된 프로토콜 버퍼 기반 API를 구현합니다.

gRPC에 대한 더 자세한 내용은, [공식 gRPC 문서](http://www.grpc.io/docs/guides/)를 확인하십시오.

### BatchRequest

모든 KV 작업 요청은 [protobuf](https://en.wikipedia.org/wiki/Protocol_Buffers)에 묶여 제공되며 `BatchRequest`이라고 불립니다. 이 일괄처리의 목적지는 `BatchRequest` 헤더에 있는, 트랜잭션 레코드로 식별됩니다.(노드가 `BatchRequest`에 응답할 때는 protobuf의 `BatchResponse`을 사용합니다.)

이 `BatchRequest`은 gRPC(protocol buffers를 쓰는)를 사용하여 노드간에 요청을 보낼 때도 사용합니다.

### DistSender

게이트웨이/조정 노드의 `DistSender`는 자신의 `TxnCoordSender`에서 `BatchRequest`를 받습니다. `DistSender`는 `BatchRequests`를 해제하고 `meta2` 레인지를 사용하여 새로운 `BatchRequests`들을 전달할 책임이 있습니다. 캐시를 이용해 리스홀더에게 요청을 보내며, "근접"한 순서로 다른 레플리카에 보낼 준비를 하고 있습니다. 캐시에서 리스홀더로 확인된 레플리카를 목록의 처음으로 이동시킨 후 모든 레플리카에 RPC를 순서대로 보냅니다.

리스홀더가 아닌 노드에서 요청이 오면 마지막으로 확인된 리스홀더를 가리키는 에러와 함께 실패합니다. 이러한 요청은 게이트웨이 노드에 의해 갱신된 리스홀더로 재시도되고 클라이언트에 절대 전돨되지 않습니다.

노드가 이러한 명령에 대한 응답을 시작하면, `DistSender`는 결과를 클라이언트에 반한화기 위해 집계합니다.

### 메타 레인지 KV 구조

클러스터의 다른 모든 데이터와 마찬가지로, 메타 레인지는 KV 쌍으로 구성됩니다. 두 메타 레인지 모두 비슷한 구조를 가집니다:

~~~
metaX/successorKey -> LeaseholderAddress, [list of other nodes containing data]
~~~

요소 | 설명
--------|------------------------
`metaX` | 메타 레인지의 레벨입니다. 우리는 `meta1` 또는 `meta2`로 단순화했지만, 실재 `cockroach`는 `\x02`와 `\x03`으로 표현합니다. |
`successorKey` | 당신의 조회할 키보다 *큰* 첫 키입니다. 이것은 카크로치디비의 조회를 효율적으로 만듭니다; 찾고자 하는 키보다 큰 값을 찾을 때까지 키를 스캔하기만 하면 관련 데이터를 찾을 수 있습니다.<br/><br/>키 공간의 끝에 대한 `successorKey`는 `maxKey`로 식별됩니다.
`LeaseholderAddress` | 리스홀더로 알려진, 읽기와 쓰기를 담당하는 레플리카입니다. 복제 계층에는 [리스](replication-layer.html#leases)에 대한 더 자세한 내용이 포함되어 있습니다. |

다음은 그 예입니다:

~~~
meta2/M -> node1:26257, node2:26257, node3:26257
~~~

이 경우, `node1`은 레플리카는 리스홀더이고, 노드 2와 3도 레플리카를 가지고 있습니다.

#### 예

조회를 위해 알파벳 순으로 정렬된 열이 있다고 가정해봅시다. 다음은 메타 레인지의 대략적인 모습입니다:

1. `meta1`은 `meta2` 레플리카를 포함하는 노드의 주소를 포합합니다.

    ~~~
    # Points to meta2 range for keys [A-M)
    meta1/M -> node1:26257, node2:26257, node3:26257

    # Points to meta2 range for keys [M-Z]
    meta1/maxKey -> node4:26257, node5:26257, node6:26257
    ~~~

2. `meta2`는 클러스터의 각 레인지 레플리카를 포함하는 노드에 대한 주소를 포함하며, 첫 번째 노드는 [리스홀더](replication-layer.html#leases)입니다.

    ~~~
    # Contains [A-G)
    meta2/G -> node1:26257, node2:26257, node3:26257

    # Contains [G-M)
    meta2/M -> node1:26257, node2:26257, node3:26257

    #Contains [M-Z)
    meta2/Z -> node4:26257, node5:26257, node6:26257

    #Contains [Z-maxKey)
    meta2/maxKey->  node4:26257, node5:26257, node6:26257
    ~~~

### 테이블 데이터 KV 구조

테이블의 데이터를 나카내는 키-밸류 데이터는 다음 구조를 사용합니다:

~~~
/<table Id>/<index id>/<indexed column values> -> <non-indexed/STORING column values>
~~~

테이블 자체는 `기본키` 열에 대해 `index_id`가 1로 저장되고, 테이블의 나머지 열은 저장/포함된 열로 간주됩니다.

### 레인지 디스크립터

카크로치디비의 각 레인지에는 레인지 디스크립터로 알려진 메타데이터가 포함되어 있습니다. 레인지 디스크립터는 다음으로 구성됩니다:

- 연속적인 레인지 식별자
- 레인지가 포함한 키공간(즉, 키 집합); 예를 들어, 테이블의 KV 구조에서 처음과 마지막의 `<인덱스된 열 값>`. 이것은 `meta2` 레인지의 키들 결정합니다.
- 첫 번째 위치에 리스홀더(읽기와 쓰기를 책임지는)가 있는, 레인지 복제본을 포함하는 주소들. 이것은 `meta2` 레인지의 키 값을 결정합니다.

레인지 디스크립터는 `meta2` 레인지의 키-밸류 데이터를 포함하기 때문에, 각 노드의 `meta2` 캐시는 레인지 디스크립터도 포합합니다.

레인지 디스크립터는 다음과 같은 경우에 업데이트됩니다:

- 레인지 Raft 그룹에 대한 멤버십 변경(자세한 내용은 [복제 계층](replication-layer.html#membership-changes-rebalance-repair)에서 다루어짐)
- 리스홀더 변경
- 레인지 분할

레인지 디스크립터에 대한 업데이트는 로컬 레인지에서 발생하고, `meta2` 레인지로 전파됩니다.

### 레인지 분할

기본적으로, 카크로치디비는 레인지/레플리카를 64MiB로 유지하려고 합니다. 레인지가 한계에 도달하면 이를 두 개의 32MiB 레인지(인접한 키 공간으로 구성)로 분할합니다.

이 레인지 분할 과정에 노드는 분할된 레인지와 동일한 구성원을 모두 포함하는 새로운 Raft 그룹을 만듭니다. 두 레인지가 생기면 레인지 디스크립터를 사용하는 노드의 주소 뿐만 아니라, `meta2`를 새로운 키공간의 경계로 업데이트하는 트랜잭션이 만들어집니다.

## 다른 계층과의 기술적인 상호작용

### 분산과 트랜잭션 계층

분산 계층의 `DistSender`는 자기 노드의 트랜잭션 계층에 있는 `TxnCoordSender`로부터 `BatchRequests`를 받습니다.

### 분산과 복제 계층

분산 계층은 `BatchRequests`를 데이터를 포함하는 레인지들로 전송하며, 궁극적으로 복제 계층에서  Raft 그룹 리더 또는 리스홀더에게 전달됩니다.

## 무엇을 더 알아볼까요?

카크로치디비가 어떻게 데이터를 카피하고 이를 보장하는지 [복제 계층](replication-layer.html)에서 알아봅시다.
