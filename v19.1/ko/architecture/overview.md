---
title: 아키텍처 개요
summary: 카크로치디비 아키텍처의 개요입니다.
toc: true
key: cockroachdb-architecture.html
redirect_from: index.html
---

카크로치디비는 스케일가능하고 일관성있는, 소스코드에 접근가능한 데이터베이스로 디자인되었습니다. 개발자는 종종 우리가 어떻게 이것을 달성했는지 질문하는데, 이 가이드는 `카크로치` 프로세스의 세부동작을 자세하게 설명합니다.

하지만, 카크로치디비를 사용하기 위해 기본 아키텍처를 이해할 필요는 없습니다. 이 페이지는 심층 사용자와 데이터베이스 애호가에게 내부에서 무슨 일이 일어나는지 설명합니다.

## 가이드 사용법

이 가이드는 카크로치디비의 각 계층을 자세히 설명하는 페이지로 나뉩니다. 순차적으로(개요에서 SQL 계층 순으로) 읽는 것이 좋습니다.

카크로치디비에 대한 고수준의 이해를 원하면 각 계층의 **개요**를 읽으십시오. 더 기술적인 세부내용(예를 들어 [프로젝트에 기여](../contribute-to-cockroachdb.html) 하는 것에 관심이 있다면) 각 **구성요소**도 읽어야 합니다.

{{site.data.alerts.callout_info}}이 가이드는 카크로치디비의 구조에 대해 자세히 설명하지만, <em>당신이</em> 카크로치디비를 사용하여 애플리케이션을 구성하는 방법에 대해서는 설명하지 않습니다. 카크로치디비를 사용한 애플리케이션 아키텍처에 대한 도움말을 모려면 <a href="https://cockroachlabs.com/docs/stable">사용자 문서</a>를 확인하십시오.{{site.data.alerts.end}}

This guide details how CockroachDB is built, but does not explain how <em>you</em> should architect an application using CockroachDB. For help with your own application's architecture using CockroachDB, check out our <a href="https://cockroachlabs.com/docs/stable">user documentation</a>.{{site.data.alerts.end}}

## 카크로치디비의 목적

카크로치디비는 다음 목적을 달성하도록 디자인되었습니다:

- 인간의 삶을 편하게 합니다. 운영자에게 적은 조작과 고도의 자동화를 제공하고, 개발자에게는 간단하고 합리적입니다.
- 확장성이 뛰어남과 동시에 업계 최고의 일관성을 제공합니다. 분산 트랜잭션을 가능하게 하고 이벤츄얼 컨시스턴시와 스테일 리드로 인한 고통을 제거합니다.
- 읽기와 쓰기가 모든 노드에서 충돌없이 가능한 언제나 동작하는 데이터베이스를 만듭니다.
- 플랫폼이나 벤더 의존성 없이, 어떤 환경에서나 유연하게 배포가능합니다.
- 관계형 데이터와 상호작용하는 익숙한 도구를 제공합니다.(예: SQL)

이러한 기능이 합쳐져, 카크로치디비를 통해 글로벌하고 확장 가능하며 탄력있는 클라우드 서비스를 손쉽게 구축하기를 바랍니다.

## 용어

### 단어

아키텍처 문서를 보기 전에 몇 가지 단어를 알아보면 도움이 됩니다.

{% include {{ page.version.version }}/misc/basic-terms.md %}

### 개념

카크로치디비는 다음 개념에 크게 의존하므로, 익숙해지면 아키텍처 목표를 이해하는데 도움이 됩니다.

단어 | 정의
-----|-----------
**일관성** | 카크로치디비는 [ACID 개념](https://en.wikipedia.org/wiki/Consistency_(database_systems)) 과 [CAP 이론](https://en.wikipedia.org/wiki/CAP_theorem) 모두에 "일관성"을 사용합니다. 이 용어로 우리는 데이터에 이상현상이 없어야 한다는 것을 표현합니다.
**합의** | 레인지가 쓰기를 받으면, 레플리카를 가진 노드 중 쿼럼이 쓰기를 확인합니다. 이는 데이터가 안전하게 저장되고 노드의 대다수가 데이터베이스의 현재 상태에 동의한다는 것을 의미합니다(노드의 일부가 오프라인이더라도).<br/><br/>만약 쓰기가 합의를 달성하지 *못하면* 클러스터 내에서 일관성을 유지하기 위해 추가진행이 중단됩니다.
**복제** | 복제에는 데이터 사본을 만들고 배포하는 작업과, 사본의 일관성 유지 작업이 포함됩니다. 복제에는 동기와 비동기 유형이 있습니다.<br/><br/>동기식 복제에서는 커밋되기 전에 모든 쓰기가 데이터 복사본의 쿼럼으로 전파되어야 합니다. 데이터의 일관성을 유지하기 위해, 카크로치디비가 사용하는 복제 종류입니다.<br/><br/>비동기 복제는 커밋으로 가정하기 위해 단일 노드만을 확인합니다. 그 후에 데이터를 각 복사본에 전파합니다. 이것은 NoSQL 데이터베이스에 의해 대중화된 "이벤츄얼 컨시스턴시"와 유사합니다. 이 복제방법은 이상현상과 데이터 손실을 일으킬 수 있습니다.
**트랜잭션** | 데이터베이스에 수행되는 일련의 작업은 [ACID 개념](https://en.wikipedia.org/wiki/Database_transaction)을 준수합니다. 이는 일관된 시스템의 핵심 구성요소로 개발자가 데이터베이스를 신뢰할 수 있게 합니다.
**멀티-액티브 가용성** | 합의에 기반한 고가용성에 대한 개념으로 클러스트의 각 노드가 저장된 데이터의 하위 집합에 대해 읽기 및 쓰기를 처리하게 합니다(레인지 기반으로). 이는 액티브 노드가 트래픽의 100%를 처리하는, 액티브-패시브 복제나, 모든 노드가 요청을 수락하지만 일반적으로 읽기가 최신인지 보장할수 없는 액티브-액티브 복제와는 다른 방식입니다.

## 개요

카크로치디비는 두가지 명령으로 장비에서 실행됩니다:

- `cockroach start` 명령어의 `--join` 플래그로 클러스터의 모든 초기 노드를 지정하여, 프로세스가 모든 다른 장비를 알고 통신하며
- `cockroach init` 는 한 번에 클러스터를 초기화합니다

`카크로치` 프로세스가 실행되면, 개발자는 SQL API(PostgreSQL과 동일한)를 통해 카크로치디비를 사용할 수 있습니다. 모든 노드가 동일하게 동작하기 때문에 어떤 노드에라도 SQL 요청을 보낼수 있습니다; 이로 인해 카크로치디비는 로드 밸런서와 쉽게 통합됩니다.

SQL RPC를 수신한 노드는, 이를 분산 키밸류 저장소와 동작하는 명령으로 변경합니다. 이러한 RPC가 클러스테어 데이터를 채울 때, 카크로치디비는 알고리즘을 이용해 노드 간 데이터를 64MiB 청크로 분산시키며 우리는 이것을 레인지라고 부릅니다. 각 레인지는 생존성을 보장하기 위해 최소 3개의 노드로 복제됩니다. 이렇게 하면 노드가 다운되어도, 읽기 및 쓰기를 할 수 있는 데이터의 사본이 남아있으며, 다른 노드에 데이터를 복제할 수 있습니다.

만약 노드가 직접 읽거나 쓸 수 없는 요청을 받게 된다면, 처리할 수 있는 노드를 찾아 통신합니다. 이렇게 하여 당신은 데이터가 어디에 있는지 알 필요가 없으며, 카크로치디비가 각 노드에 대해 대응하는 동작을 하게 합니다.

레인지에서 데이터를 변경하면 합의 알고리즘에 의존하여 복제본의 다수가 변경을 커밋하는데 동의하게 되며, 어떤 노드와 통신하는지에 관계없이, 업계최고의 독립성과 애플리케이션에 일관적인 읽기를 보장합니다.

궁극적으로, 데이터를 디스크에 쓰고 읽을 때 효율적인 스토리지 엔진을 사용하며, 이 엔진은 데이터의 타임스탬프를 추적할 수 있습니다. 이것은 SQL 표준인 `AS OF SYSTEM TIME`절을 지원하여 일정 기간 동안 히스토리컬 데이터를 찾을 수 있게 합니다.

높은 수준의 개요가 당신에게 카크로치디비가 하는 것의 개념을 제공하지만, `cockroach` 프로세스가 이러한 요구사항에 어떻게 작동하는지 살펴보녀 아키텍처에 대한 이해를 훨씬 높일 수 있습니다.

### 계층

높은 레벨에서, 카크로치디비는 클라이언트의 SQL 문을 키밸류(KV) 데이터로 변경하여 노드에 분산시켜 디스크에 키록합니다. 우리의 아키텍처는 이를 수행하는 과정이며, 위 아래에 있는 계층과 상호작용하는 여러 개의 상대적으로 불투명한 서비스 계층으로 표현됩니다.

다음 페이지는 각 계층이 수행하는 기능을 설명하고, 다른 계층의 세부사항을 대부분 무시합니다. 이 설명은 계층 자체 해당하며, 일반적으로 다른 계층을 블랙박스 API로 다룹니다. 명확하게 표현되지 *않은* 계층 간의 상호작용이 있으며, 전체 프로세스를 이해하기 위해 각 계층을 기능을 이해해야 합니다.

계층 | 순서 | 목적
------|------------|--------
[SQL](sql-layer.html)  | 1  | 클라이언트의 SQL을 KV 명령어로 변경합니다.
[트랜잭션](transaction-layer.html)  | 2  | 여러 KV 항목에 대한 원자적 변경을 지원합니다.
[Distribution](distribution-layer.html)  | 3  | 복제된 KV 레인지를 단일 항목으로 제공합니다.
[Replication](replication-layer.html)  | 4  | 일관성있고 동기적으로 KV 레인지를 여러 노드에 복제합니다. 이 계층은 리스를 사용해 일관성있는 읽기를 보장합니다. 
[스토리지](storage-layer.html)  | 5  | KV 데이터를 디스크에 쓰고 읽습니다.

## 무엇을 더 알아볼까요?

[SQL 계층](sql-layer.html)에서 카크로치디비가 애플리케이션과 어떻게 상호작용하는지 배워 아키텍처에 대해 알아봅시다.
