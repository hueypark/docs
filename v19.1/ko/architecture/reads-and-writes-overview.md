---
title: 카크로치디비에서의 읽기와 쓰기
summary: 카크로치디비의 복제되는 분산 환경의 데이터 특성에 의해 읽기와 쓰기가 어떤 영향을 받는지 알아봅니다.
toc: true
---

이 페이지는 카크로치디비의 복제되는 분산 환경의 데이터 특성에 의해 읽기와 쓰기가 어떤 영향을 받는지 설명합니다. 중요 [카크로치디비 아키텍처 개념](overview.html)을 요약한 다음 몇 가지 간단한 읽기와 쓰기 시나리오를 안내합니다. 

{{site.data.alerts.callout_info}}
카크로치디비 아키텍처에서 쿼리에 대한 좀 더 자세한 내용은, [분산 트랜잭션의 수명](life-of-a-distributed-transaction.html)에서 확인가능합니다.
{{site.data.alerts.end}}

## 주요 개념

{% include {{ page.version.version }}/misc/basic-terms.md %}

위에서 업급했듯이, 쿼리가 실행되면, 클러스터는 데이터가 들어있는 레인지의 리스홀더에게 요청을 전달합니다. 쿼리가 여러 레인지를 요구하면, 요청은 여러 리스홀더에게 전달됩니다. 읽기 요청의 경우, 리스홀더만 데이터를 검색합니다. 쓰기 요청의 경우, Raft 합의 프로토콜은 쓰기가 커밋되기 전에 레인지에 있는 대부분의 레플리카가 동의해야 한다고 규정합니다.

이 메커니즘이 가상의 쿼리에서 어떻게 동작하는지 생각해 봅시다.

## 읽기 시나리오

먼저, 간단한 읽기 시나리오입니다:

- 클러스터에 3개의 노드가 있습니다.
- 3개의 작은 테이블이, 단일 레인지에 위치해 있습니다.
- 레인지는 3개의 복제본을 가집니다 (기본값).
- 쿼리는 노드 2에서 테이블 3을 읽습니다.

<img src="{{ 'images/v19.1/perf_tuning_concepts1.png' | relative_url }}" alt="Perf tuning concepts" style="max-width:100%" />

이 경우:

1. 노드 2 (게이트웨이 노드) 테이블 3을 읽으려는 요청을 받습니다.
2. 테이블 3의 리스홀더는 노드 3에 있기 때문에, 요청은 전달됩니다.
3. 노드 3은 데이터를 노드 2에게 반환합니다.
4. 노드 2가 클라이언트에 응답합니다.

만약 리스홀더가 있는 노드가 쿼리를 수신하면 네트워크 전송이 줄어듭니다:

<img src="{{ 'images/v19.1/perf_tuning_concepts2.png' | relative_url }}" alt="Perf tuning concepts" style="max-width:100%" />

## 쓰기 시나리오

이제 노드 3에 쿼리를 실행하여 테이블 1에 쓰는 쓰기 시나리오를 살펴보겠습니다:

<img src="{{ 'images/v19.1/perf_tuning_concepts3.png' | relative_url }}" alt="Perf tuning concepts" style="max-width:100%" />

이 경우:

1. 노드 3 (게이트웨이 노드)가 테이블 1에 쓰는 요청을 받습니다.
2. 테이블 1의 리스홀더는 노드 1이기 때문에, 요청은 그 쪽으로 전달됩니다.
3. 리스홀더는 Raft 리더와 동일한 복제본(일반적으로)이므로, 스스로의 Raft 로그에 쓰는 동시에 팔로워 레플리카인 노드 2와 3에 통지합니다.
4. 한 팔로워가 Raft 로그에 쓴 후(대부분의 레플리카가 Raft 로그에 동의함), 리더에게 알리고 쓰기는 동의되어 키-밸류 값으로 커밋됩니다. 이 다이어그램에서는 노드 2가 쓰기를 확정했지만, 노드 3이 될 수도 있습니다. 또 합의에 참여하지 않은 팔로워는 보통 빠를 시간 내에 커밋됩니다.
5. 노드 1은 노드 3에 커밋 승인을 반환합니다.
6. 노드 3이 클라이언트에 응답합니다.

읽기 시나리오와 마찬가지로, 리스홀더를 가진 Raft 리더가 있는 노드가 쓰기 요청을 수신하면 네트워크 전송이 줄어듭니다:

<img src="{{ 'images/v19.1/perf_tuning_concepts4.png' | relative_url }}" alt="Perf tuning concepts" style="max-width:100%" />

## 네트워크와 I/O 병목

위의 예를 염두에 두고, 네트워크 지연 및 I/O를 잠재적인 성능 병목으로 생각하는 것이 중요합니다. 요약하자면:

- 읽기의 경우, 게이트웨이 노드와 리스홀더 사이의 전송이 대기시간을 늘립니다.
- 읽기의 경우, 게이트웨이 노드와 리스홀더/Raft 리더 사이 또는 리스홀더/Raft 리더와 Raft 팔로워 사이의 전송이 대기시간을 늘립니다. 또 쓰기가 커밋되기 전에 Raft 로그가 디스크에 유지되므로 디스크 I/O가 중요합니다.
